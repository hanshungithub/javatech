## 2 java内存区域与内存溢出异常
#### 2.2 运行时数据区
    Java虚拟机在执行Java程序的过程中会把管理的内存划分为若干个不同的数据区
    1，方法区
    2，堆
    3，虚拟机栈
    4，本地方法栈
    5，程序计数器
    其中方法区、堆是所有线程共享的数据区，虚拟机栈、本地方法栈、程序计数器是线程隔离的
##### 2.2.1 程序计数器
    程序计数器是一块较小的内存空间，它可以看做是当前线程所执行字节码的行号指示器
    如果线程正在执行的是一个java方法，这个程序计数器记录的是虚拟机字节码指令的地址，如
    果正在执行的是native方法，这个计数器值则为空，此内存区域是唯一一个在Java虚拟机规范
    中没有规定任何OutOfMemoryError情况的区域
##### 2.2.2 Java虚拟机栈
    1，它是线程私有的生命周期与线程相同，虚拟机栈描述的是Java方法执行的内存模型：每个方法
    在执行的同时都会创建一个栈针，用于存储局部变量表、操作数栈、动态链接、方法出口等信
    息，每一个方法从调用到执行完的过程，就对应着一个栈针在虚拟机栈从入栈到出栈。
    2，局部变量表存放了编译期间可知的基本数据类型、对象引用（不等同于对象本身，可能指向一个
    对象起始地址的引用指针，也可能是对象的句柄与相关的位置）
    3，这个区域有两种异常，如果线程请求的栈深度大于虚拟机所允许的深度，将会抛出StackOverFlowError，如果虚拟机可以动态扩展，在扩展是申请不到足够的内存就会抛出
    OutOfMemoryError异常
##### 2.2.3 本地方法栈
    本地方法栈和Java虚拟机栈一样，只不过是为本地方法服务的
##### 2.2.4 Java堆
    Java堆是Java虚拟机中所管理最大的一块，所有的对象的实例和数组都要在堆上分配的
    Java堆是垃圾收集器管理的主要的区域，Java堆可以细分为：新生代和老年代，再细分
    一点：Eden空间、FromSurvivor空间、Tosurvivor空间等。如果堆中没有内存完成
    实例分配，并且堆无法扩展时，将会抛出OutOfMemoryError异常
##### 2.2.5 方法区
    Java方法区用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的
    代码数据等
##### 2.2.6 运行时常量池
    是方法区的一部分，用于存放编译期生成的各种字面量和符号引用
#### 2.3 HotSpot虚拟机解密
##### 2.3.1 对象的创建
    虚拟机在遇到一个new指令是，首先会去检查这个指令的参数是否能在常量池中定位到一个
    类的符号引用，并检查这个符号引用的类是否被加载解析初始化过，如果没有则执行相应的
    类加载过程。
    指针碰撞法分配
    空闲列表法
##### 2.3.2 Java对象的内存布局
    对象的布局：对象头、实例数据、对其填充
    对象头包括两部分：第一部分用于存储对象自身运行时的数据，第二部分：类型指针，即对
    象指向它的类元数据的指针，虚拟机通过这个指针确定这个对象是哪个类的实例，如果对象
    是数组，对象头中还需要一块来记录数组长度的数据
##### 2.3.3 对象的访问定位
    句柄访问： 
        Java堆中将会划分出一块内存作为句柄池，reference存储的就是对象的句柄地址，
        句柄中包含了对象实例数据与类型数据各自的具体地址信息。
    直接指针访问：
        Java堆中对象的布局就必须考虑如何安放，访问类型数据的相关信息，reference
        中存储的直接就是对象地址
    这两种对象访问方式各有优势，使用句柄访问的最大好处就是reference中村吃的是稳定
    的句柄地址，如果对象被移动时只会改变句柄池中的实例数据指针，而reference不会改变
    使用直接指针访问的最大好处就是速度更快，它节省了一次指针定位的时间开销 
## 3 垃圾收集与内存分配策略
##### 3.2 判断哪些对象需要回收
##### 3.2.1 引用计数法
    给对象中添加一个引用计数器，每当有一个地方应用它的时候，计数器的值就加1，当引用
    失效时，计数器的值就减1，任何时刻计数器值为0的对象就是不可能再被使用的
    注：主流的Java虚拟机没有选用引用计数法，最主要的原因在意它难以解决对象之间相互
    循环引用的问题
##### 3.2.2 可达性分析算法
    通过一系列的称为"GC Roots"的对象为起始点，从这些节点开始向下搜索，搜索走过的路
    径称为引用链，当一个对象到达GC Roots没有任何引用链时，则证明此对象时不可用的
    在Java语言中可以作为GC Roots有一下几种：
        虚拟机栈（栈帧中的本地变量表）中引用的对象
        方法区中类静态属性引用的对象
        方法区中常量引用的对象
        本地方法栈中JNI引用的对象
##### 3.2.3 引用
    1，强引用就是指在程序代码之间普遍存在的，类似于“Object obj = new Object()”这
    类的引用，只要强引用还存在，垃圾收集器永远不会回收掉别引用的对象
    2，软引用是用来描述一些有用但非必要的对象，对于软引用关联的对象，在系统将要发生
    内存溢出之前，将会把这些对象列进回收范围之中进行第二次回收
    3，弱引用也是用来描述非必须对象的，但它的强度要比软引用更弱一些，被软引用关联的
    对象只能生存到下一次垃圾收集器之前
    4，虚引用是最弱的一种引用，一个对象是否有虚引用的存在，完全不会对其生存时间构成
    影响，也无法通过虚引用取得一个对象实例
## 3.3 垃圾回收算法
##### 3.3.1 标记-清除算法
    算法分为“标记”和“清除”两个阶段，首先标记处所有需要回收的对象，在标记完成后统一
    回收所有被标记的对象
    不足之处：
        一个是效率问题，标记和清除两个过程效率都不高，另一个是空间问题，标记清除后
        会产生大量的不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需
        要分配较大的对象，无法找到足够的空降而不得不提前进行一次垃圾回收
##### 3.3.2 复制算法
    它将内存按容量划分为大小，每次只使用其中的一块，当这一块的内存用完了就将还存活
    的对象复制到另一块上面，然后把已使用过的内存空间一次性清理掉
##### 3.3.3 标记-整理算法
    与标记-清除算法一样，让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存
##### 3.3.4 分代收集算法
    根据对象存活的存活周期的不同将内存划分为几块，
## 3.5 垃圾收集器
##### 3.5.1 Serial收集器
    是一个单一线程的收集器，在进行垃圾回收时，必须暂停其他所有的工作线程，直到收集
    结束
##### 3.5.2 ParNew 收集器
    ParNew收集器其实就是Serial的多线程版本
##### 3.5.3 Parallel Scavenge收集器
    Parallel Scavenge是一个新生代收集器，它是使用复制算法的收集器又是并行多线程
    收集器
    Parallel Scavenge收集器的目的是达到一个可控吞吐量的
##### 3.5.4 Serial Old 收集器
    Serial Old收集器是Seria收集器的老年代版本，同样是使用单一线程，使用标记-整理
    算法，主要意义是给client模式下使用，如果是server端，一是搭配ParalellScavenge
    使用，而是作恶日CMS收集器的后配方案
##### 3.5.5 Paralell Old 收集器
    Parallel Old收集器是Parallel Scavenge的老年代版本，使用多线程标记-整理算法
##### 3.5.6 CMS 收集器
    CMS收集器是一种以获取最短回收停顿时间为目标的收集器，是基于标记-清除算法的实现
    CMS收集的步骤：
        初始标记
        并发标记
        重新标记
        并发清除
    缺点：
        CMS对CPU非常的敏感
        无法浮动处理垃圾
        会产生空间碎片
##### 3.5.7 G1 收集器
    优点：
        并发与并行
        分代收集
        空间整合 基于标记-整理
        可预测的停顿
## 3.6 内存分配与回收策略
##### 3.6.1 对象优先分配在Eden
    大多数情况下，对象在新生代Eden区中分配，当Eden没有足够的空间进行分配的时，虚拟机
    将发生一次minorgc
##### 3.6.2 大对象直接进入老年代
    所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的就是那种很长的字符串以
    及数组
##### 3.6.3 长期存活的对象将进入老年代
    虚拟机会给每个对象定义了一个对象年龄计数器，如果对象在Eden出生并经过第一次minor
    gc后，仍然存活，并且能被survivor容纳的话，将被移到survivor中，并且对象年龄设定
    为1，对象在survivor中每经过一次gc，年龄就加1，当年龄达到一定的程度（默认是15）
    就将会晋升到老年代
##### 3.6.5 空间担保
    
        
            

       

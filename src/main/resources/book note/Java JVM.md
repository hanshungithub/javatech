## 2 java内存区域与内存溢出异常
#### 2.2 运行时数据区
    Java虚拟机在执行Java程序的过程中会把管理的内存划分为若干个不同的数据区
    1，方法区
    2，堆
    3，虚拟机栈
    4，本地方法栈
    5，程序计数器
    其中方法区、堆是所有线程共享的数据区，虚拟机栈、本地方法栈、程序计数器是线程隔离的
##### 2.2.1 程序计数器
    程序计数器是一块较小的内存空间，它可以看做是当前线程所执行字节码的行号指示器
    如果线程正在执行的是一个java方法，这个程序计数器记录的是虚拟机字节码指令的地址，如
    果正在执行的是native方法，这个计数器值则为空，此内存区域是唯一一个在Java虚拟机规范
    中没有规定任何OutOfMemoryError情况的区域
##### 2.2.2 Java虚拟机栈
    1，它是线程私有的生命周期与线程相同，虚拟机栈描述的是Java方法执行的内存模型：每个方法
    在执行的同时都会创建一个栈针，用于存储局部变量表、操作数栈、动态链接、方法出口等信
    息，每一个方法从调用到执行完的过程，就对应着一个栈针在虚拟机栈从入栈到出栈。
    2，局部变量表存放了编译期间可知的基本数据类型、对象引用（不等同于对象本身，可能指向一个
    对象起始地址的引用指针，也可能是对象的句柄与相关的位置）
    3，这个区域有两种异常，如果线程请求的栈深度大于虚拟机所允许的深度，将会抛出StackOverFlowError，如果虚拟机可以动态扩展，在扩展是申请不到足够的内存就会抛出
    OutOfMemoryError异常
##### 2.2.3 本地方法栈
    本地方法栈和Java虚拟机栈一样，只不过是为本地方法服务的
##### 2.2.4 Java堆
    Java堆是Java虚拟机中所管理最大的一块，所有的对象的实例和数组都要在堆上分配的
    Java堆是垃圾收集器管理的主要的区域，Java堆可以细分为：新生代和老年代，再细分
    一点：Eden空间、FromSurvivor空间、Tosurvivor空间等。如果堆中没有内存完成
    实例分配，并且堆无法扩展时，将会抛出OutOfMemoryError异常
##### 2.2.5 方法区
    Java方法区用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的
    代码数据等
##### 2.2.6 运行时常量池
    是方法区的一部分，用于存放编译期生成的各种字面量和符号引用
#### 2.3 HotSpot虚拟机解密
##### 2.3.1 对象的创建
    虚拟机在遇到一个new指令是，首先会去检查这个指令的参数是否能在常量池中定位到一个
    类的符号引用，并检查这个符号引用的类是否被加载解析初始化过，如果没有则执行相应的
    类加载过程。
    指针碰撞法分配
    空闲列表法
##### 2.3.2 Java对象的内存布局
    对象的布局：对象头、实例数据、对其填充
    对象头包括两部分：第一部分用于存储对象自身运行时的数据，第二部分：类型指针，即对
    象指向它的类元数据的指针，虚拟机通过这个指针确定这个对象是哪个类的实例，如果对象
    是数组，对象头中还需要一块来记录数组长度的数据
##### 2.3.3 对象的访问定位
    句柄访问： 
        Java堆中将会划分出一块内存作为句柄池，reference存储的就是对象的句柄地址，
        句柄中包含了对象实例数据与类型数据各自的具体地址信息。
    直接指针访问：
        Java堆中对象的布局就必须考虑如何安放，访问类型数据的相关信息，reference
        中存储的直接就是对象地址
    这两种对象访问方式各有优势，使用句柄访问的最大好处就是reference中村吃的是稳定
    的句柄地址，如果对象被移动时只会改变句柄池中的实例数据指针，而reference不会改变
    使用直接指针访问的最大好处就是速度更快，它节省了一次指针定位的时间开销 
## 3 垃圾收集与内存分配策略
##### 3.2 判断哪些对象需要回收
##### 3.2.1 引用计数法
    给对象中添加一个引用计数器，每当有一个地方应用它的时候，计数器的值就加1，当引用
    失效时，计数器的值就减1，任何时刻计数器值为0的对象就是不可能再被使用的
    注：主流的Java虚拟机没有选用引用计数法，最主要的原因在意它难以解决对象之间相互
    循环引用的问题
##### 3.2.2 可达性分析算法
    通过一系列的称为"GC Roots"的对象为起始点，从这些节点开始向下搜索，搜索走过的路
    径称为引用链，当一个对象到达GC Roots没有任何引用链时，则证明此对象时不可用的
    在Java语言中可以作为GC Roots有一下几种：
        虚拟机栈（栈帧中的本地变量表）中引用的对象
        方法区中类静态属性引用的对象
        方法区中常量引用的对象
        本地方法栈中JNI引用的对象
##### 3.2.3 引用
    1，前饮用就是指在程序代码之间普遍存在的，类似于“Object obj = new Object()”这
    类的引用，只要强引用还存在，垃圾收集器永远不会回收掉别引用的对象
    2，软引用是用来描述一些有用但非必要的对象，对于软引用关联的对象，在系统将要发生
    内存溢出之前
       

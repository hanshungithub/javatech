## 2 java内存区域与内存溢出异常
#### 2.2 运行时数据区
    Java虚拟机在执行Java程序的过程中会把管理的内存划分为若干个不同的数据区
    1，方法区
    2，堆
    3，虚拟机栈
    4，本地方法栈
    5，程序计数器
    其中方法区、堆是所有线程共享的数据区，虚拟机栈、本地方法栈、程序计数器是线程隔离的
##### 2.2.1 程序计数器
    程序计数器是一块较小的内存空间，它可以看做是当前线程所执行字节码的行号指示器
    如果线程正在执行的是一个java方法，这个程序计数器记录的是虚拟机字节码指令的地址，如
    果正在执行的是native方法，这个计数器值则为空，此内存区域是唯一一个在Java虚拟机规范
    中没有规定任何OutOfMemoryError情况的区域
##### 2.2.2 Java虚拟机栈
    1，它是线程私有的生命周期与线程相同，虚拟机栈描述的是Java方法执行的内存模型：每个方法
    在执行的同时都会创建一个栈针，用于存储局部变量表、操作数栈、动态链接、方法出口等信
    息，每一个方法从调用到执行完的过程，就对应着一个栈针在虚拟机栈从入栈到出栈。
    2，局部变量表存放了编译期间可知的基本数据类型、对象引用（不等同于对象本身，可能指向一个
    对象起始地址的引用指针，也可能是对象的句柄与相关的位置）
    3，这个区域有两种异常，如果线程请求的栈深度大于虚拟机所允许的深度，将会抛出StackOverFlowError，如果虚拟机可以动态扩展，在扩展是申请不到足够的内存就会抛出
    OutOfMemoryError异常
##### 2.2.3 本地方法栈
    本地方法栈和Java虚拟机栈一样，只不过是为本地方法服务的
##### 2.2.4 Java堆
    Java堆是Java虚拟机中所管理最大的一块，所有的对象的实例和数组都要在堆上分配的
    Java堆是垃圾收集器管理的主要的区域，Java堆可以细分为：新生代和老年代，再细分
    一点：Eden空间、FromSurvivor空间、Tosurvivor空间等。如果堆中没有内存完成
    实例分配，并且堆无法扩展时，将会抛出OutOfMemoryError异常
##### 2.2.5 方法区
    Java方法区用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的
    代码数据等
##### 2.2.6 运行时常量池
    是方法区的一部分，用于存放编译期生成的各种字面量和符号引用
#### 2.3 HotSpot虚拟机解密
##### 2.3.1 对象的创建
    虚拟机在遇到一个new指令是，首先会去检查这个指令的参数是否能在常量池中定位到一个
    类的符号引用，并检查这个符号引用的类是否被加载解析初始化过，如果没有则执行相应的
    类加载过程。
    指针碰撞法分配
    空闲列表法
##### 2.3.2 Java对象的内存布局
       
